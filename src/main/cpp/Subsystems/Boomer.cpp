// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Boomer.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/BoomWithJoy.h"
#include "Commands/RetractArm.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Boomer::Boomer() : frc::Subsystem("Boomer") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    cANSparkBoom.reset(new rev::CANSparkMax(8, rev::CANSparkMax::MotorType::kBrushless));
    boomLimit.reset(new frc::DigitalInput(2));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    boom_pidController = cANSparkBoom->GetPIDController();
    boom_encoder = cANSparkBoom->GetEncoder();
    double kP = 0.1, kI = 1e-4, kD = 1, kIz = 0, kFF = 0, kMaxOutput = 0.5, kMinOutput = -0.5;
}

void Boomer::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new BoomWithJoy());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    
    // set PID coefficients
    boom_pidController.SetP(kP);
    boom_pidController.SetI(kI);
    boom_pidController.SetD(kD);
    boom_pidController.SetIZone(kIz);
    boom_pidController.SetFF(kFF);
    boom_pidController.SetOutputRange(kMinOutput, kMaxOutput);


}

void Boomer::Periodic() {
    // Put code here to be run every loop

}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Boomer::JoyBoom(){
    frc::SmartDashboard::PutNumber("Boom Encoder Pos", boom_encoder.GetPosition());
    
    /*If the boom is between the low safe level and high safe level and the arm is not already in, then we
    need to Retract the Arm to stay within allowable restrictions*/
    if (boom_encoder.GetPosition() < -39 && boom_encoder.GetPosition() > -100){
        if (!frc::SmartDashboard::GetBoolean("Arm In", true)){ 
            new RetractArm();
        }
        
    }

    double boomControl = Robot::oi->getJoystick2()->GetRawAxis(1);
    bool goingUp = false;
    if (boomControl < 0) {
        //we are going up
        goingUp = true;
    }
    else {
        //we are going down
        goingUp = false;
    }
    
    double adjustedSpeed = boomControl * LIMS(boom_encoder.GetPosition(), goingUp);

    cANSparkBoom->Set(DB(adjustedSpeed/2)); // 1/2 speed
}

void Boomer::BoomUp(){
    frc::SmartDashboard::PutNumber("Boom Encoder Pos", boom_encoder.GetPosition());
    double curPos = boom_encoder.GetPosition();
    double pos0 = -13;
    double pos1 = -26;
    double pos2 = -39;
    double pos3 = -52;
    double pos4 = -65;
    double pos5 = -78;
    double pos6 = -91;
    double pos7 = -104;
    double pos8 = -117;
    double pos9 = -130;


//boom_pidController.SetReference(pos2, rev::ControlType::kPosition);
    
    
    /*
    the boom motor encoder reads inverted so as the boom raises the encoder reading goes down...
    -143 is the high limit, and 0 is all the way down.
    (-143)---pos9---pos8---pos7---pos6---pos5---pos4---pos3---pos2---pos1---pos0---0
    <--All the way UP --------------------------------------------All the way down-->
    */
    if (curPos < 0 && curPos > pos0){ //Go up to Pos0  
       boom_pidController.SetReference(pos0, rev::ControlType::kPosition);
    }
    else if (curPos < pos0 && curPos > pos1){ //Go up to Pos1
       boom_pidController.SetReference(pos1, rev::ControlType::kPosition);
    }
    else if (curPos < pos1 && curPos > pos2){ //Go up to Pos2
      boom_pidController.SetReference(pos2, rev::ControlType::kPosition);
    }
    else if (curPos < pos2 && curPos > pos3){ //Go up to Pos3
      boom_pidController.SetReference(pos3, rev::ControlType::kPosition);
    }
    else if (curPos < pos3 && curPos > pos4){ //Go up to Pos4
      boom_pidController.SetReference(pos4, rev::ControlType::kPosition);
    }
    else if (curPos < pos4 && curPos > pos5){ //Go up to Pos5
      boom_pidController.SetReference(pos5, rev::ControlType::kPosition);
    }
    else if (curPos < pos5 && curPos > pos6){ //Go up to Pos6
      boom_pidController.SetReference(pos6, rev::ControlType::kPosition);
    }
    else if (curPos < pos6 && curPos > pos7){ //Go up to Pos7
      boom_pidController.SetReference(pos7, rev::ControlType::kPosition);
    }
    else if (curPos < pos7 && curPos > pos8){ //Go up to Pos8
      boom_pidController.SetReference(pos8, rev::ControlType::kPosition);
    }
    else if (curPos < pos8 && curPos > pos9){ //Go up to Pos9
      boom_pidController.SetReference(pos9, rev::ControlType::kPosition);
    }
    
    //cANSparkBoom->Set(0.5);
    
}
void Boomer::BoomDown(){
    frc::SmartDashboard::PutNumber("Boom Encoder Pos", boom_encoder.GetPosition());
    double curPos = boom_encoder.GetPosition();
    double pos0 = -13;
    double pos1 = -26;
    double pos2 = -39;
    double pos3 = -52;
    double pos4 = -65;
    double pos5 = -78;
    double pos6 = -91;
    double pos7 = -104;
    double pos8 = -117;
    double pos9 = -130;    
    
    
    //cANSparkBoom->Set(-0.5);
    /*
    the boom motor encoder reads inverted so as the boom raises the encoder reading goes down...
    -143 is the high limit, and 0 is all the way down.
    (-143)---pos9---pos8---pos7---pos6---pos5---pos4---pos3---pos2---pos1---pos0---0
    <--All the way UP --------------------------------------------All the way down-->
    */
    if (curPos < pos0 && curPos > pos1){ //Go Down to Pos0
       boom_pidController.SetReference(pos0, rev::ControlType::kPosition);
    }
    else if (curPos < pos1 && curPos > pos2){ //Go Down to Pos1
      boom_pidController.SetReference(pos1, rev::ControlType::kPosition);
    }
    else if (curPos < pos2 && curPos > pos3){ //Go Down to Pos2
      boom_pidController.SetReference(pos2, rev::ControlType::kPosition);
    }
    else if (curPos < pos3 && curPos > pos4){ //Go Down to Pos3
      boom_pidController.SetReference(pos3, rev::ControlType::kPosition);
    }
    else if (curPos < pos4 && curPos > pos5){ //Go Down to Pos4
      boom_pidController.SetReference(pos4, rev::ControlType::kPosition);
    }
    else if (curPos < pos5 && curPos > pos6){ //Go Down to Pos5
      boom_pidController.SetReference(pos5, rev::ControlType::kPosition);
    }
    else if (curPos < pos6 && curPos > pos7){ //Go Down to Pos6
      boom_pidController.SetReference(pos6, rev::ControlType::kPosition);
    }
    else if (curPos < pos7 && curPos > pos8){ //Go Down to Pos7
      boom_pidController.SetReference(pos7, rev::ControlType::kPosition);
    }
    else if (curPos < pos8 && curPos > pos9){ //Go Down to Pos8
      boom_pidController.SetReference(pos8, rev::ControlType::kPosition);
    }
    else if (curPos < pos9 && curPos > -143){ //Go Down to Pos9
      boom_pidController.SetReference(pos9, rev::ControlType::kPosition);
    }
}
void Boomer::Stop(){
    cANSparkBoom->StopMotor();
}
/** @return 10% deadband */
double Boomer::DB(double axisVal){
    if (axisVal < -0.10)
        return axisVal;
    if (axisVal > +0.10)
        return axisVal;
    return 0;
}
double Boomer::LIMS(double limitVal, bool goingUp){
    //As the encoder reading gets closer to the limits
    //The power should be reduced

    double lowLimit = 0;
    double highLimit = -143;
    if (limitVal > -3 && !goingUp){
        return 0.25; //20% of requested speed
    }
    else if (limitVal > -10 && !goingUp){ //moving in down direction near bottom limit
        return 0.3; //30% of requested speed
    }
    else if (limitVal < -133 && goingUp){ //moving in up direction near top limit
        return 0.3; //30% of requested speed
    }
    else if (limitVal < -140 && goingUp){
        return 0.25; //20% of requested speed
    }
    else{
        return 1.0; // not near the limits - use existing values
    }

}

